"""
Depth-First Search (DFS) maze generator (iterative).
This module builds a perfect maze (a spanning tree) using a stack-based DFS
"recursive backtracker" approach. It starts from the entry cell, visits
unvisited neighbors, carves passages, and backtracks when stuck.

Output: the maze grid is modified in-place by carving walls.
"""


from __future__ import annotations
from enum import Enum
from . import wall_operations as wo
from . import direction_definitions as dirdef
from .maze_definitions import Maze
import random


class C(str, Enum):
    """ANSI color codes used to make terminal output easier to read."""
    RESET = "\033[0m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    RED = "\033[31m"
    BG_RED = "\033[41m"

    def __str__(self) -> str:
        return self.value


def dfs_maze_generator(maze: Maze, seed, forbidden_cells: set):
    """
    Generate a perfect maze using an iterative DFS approach with a stack.

    The maze is generated by visiting cells starting from the entry, carving
    passages to unvisited neighbors chosen at random, and backtracking when no
    unvisited neighbors remain. The randomness is seeded for reproducibility.

    This function mutates the maze.grid in-place.

    Raises:
        ValueError: If not all cells are reachable from the entry.
    """
    # Seed the random number generator for reproducible maze generation
    random.seed(seed)
    # Track visited coordinates to avoid revisiting cells
    visited_coords = []
    # Stack to hold the path of cells currently being explored (DFS stack)
    dfs_tracing_stack = []

    start_cell = maze.entry
    x, y = start_cell
    visited_coords.append(start_cell)
    dfs_tracing_stack.append(start_cell)

    # Continue until there are no cells left to explore in the stack
    while len(dfs_tracing_stack) != 0:
        top_element = dfs_tracing_stack[-1]
        x, y = top_element
        unvisited_neighbors = []
        # Gather unvisited neighbors within maze bounds

        for direction in dirdef.DIRECTIONS:
            dx, dy = dirdef.DIR_MOVE_DELTA[direction]
            nx = x + dx
            ny = y + dy
            if 0 <= nx < maze.width and 0 <= ny < maze.height:
                neighbor = (nx, ny)
                if (neighbor not in visited_coords and
                        neighbor not in forbidden_cells):
                    unvisited_neighbors.append(neighbor)

        if len(unvisited_neighbors) != 0:
            # Pick a random unvisited neighbor to move to next
            random_pick = random.randint(0, (len(unvisited_neighbors) - 1))
            neighbor_cell = unvisited_neighbors[random_pick]

            # Carve a passage between the current cell and the chosen neighbor
            wo.carve_coordinate(maze, top_element, neighbor_cell)
            visited_coords.append(neighbor_cell)
            dfs_tracing_stack.append(neighbor_cell)

        elif len(unvisited_neighbors) == 0:
            # No unvisited neighbors: backtrack by popping from the stack
            dfs_tracing_stack.pop()

    if (len(visited_coords) <
            ((maze.height * maze.width) - len(forbidden_cells))):
        raise ValueError(f"{C.BG_RED}Error:{C.RESET} Not all the cells are "
                         f"accessible from entry. The maze contains isolated "
                         f"cells besides the 42 marking.")

    elif (len(visited_coords) >
            ((maze.height * maze.width) - len(forbidden_cells))):
        raise ValueError(f"{C.BG_RED}Error:{C.RESET} The amount of the "
                         f"visited coordinates cannot be bigger than the "
                         f"total amount of the cells inside the maze.")
